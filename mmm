if not game:IsLoaded() then
	game.Loaded:Wait()
end

getgenv().SplittaW = { 
    Silent = {
        Enabled     = false,
        Part        = "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "RightUpperArm", "LeftUpperArm", "RightLowerLeg", "LeftLowerLeg",
        ClosestPart = false,
        
		PredictMovement    = false,
        PredictionVelocity = 0.131,
        
        AntiGroundShots = false,
        
        WallCheck   = false,
        CheckIf_KO  = false,

		UseKeybind = true,
		Keybind    = "C",
	},
    SilentFOV = {
        Visible = false,
        Radius  = 20,
    },
    Tracer = {
        Key =   "E",
        Enabled = false,
        Part    = "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso",
        ClosestPart = false,
        
		DisableTargetDeath = false,
		DisableLocalDeath  = false,
        
        UseCircleRadius      = false,
        DisableOutSideCircle = false,
        
		UseShake   = false,
		ShakeValue = 5,

		PredictMovement    = false,
        PredictionVelocity = 0.146,
        
        WallCheck  = false,
        CheckIf_KO = false,

        Smoothness = 0.022,
    },
    TracerFOV = {
        Visible = false,
        Radius  = 50,
    },
    GunFOV =  {
        Enabled = false,-- // Gun Fov / fov is automatically changed to specific gun equipped
        ["Double-Barrel SG"] = {["FOV"] = 25}, -- DB
        ["Revolver"] = {["FOV"] = 15}, -- rev
        ["SMG"] = {["FOV"] = 23}, -- smg
        ["Shotgun"] = { ["FOV"] = 20}, -- shotgun
        ["Rifle"] = { ["FOV"] = 30}, -- Rifle
        ["TacticalShotgun"] = {["FOV"] = 34}, -- rev
        ["Silencer"] = {["FOV"] = 17}, -- smg
        ["AK47"] = { ["FOV"] = 10}, -- shotgun
        ["AR"] = { ["FOV"] = 10}, -- Rifle
        -- // You Can Add Custom :p/
	},
	Both = {
		DetectDesync    = false,
		DesyncDetection = 80,
		
		UseUnderGroundKeybind = false,
		UnderGroundKey        = "X",
		
        UnderGroundReolver    = false,
		
		UsDetectDesyncKeybind = false,
		DetectDesyncKey       = "V",
		
		SendNotification      = false,
	},
}
--[Main Variables]

local plrs = game["Players"]
local rs = game["RunService"]
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local Teams = game:GetService("Teams")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local CurrentCamera = workspace.CurrentCamera
local plr = plrs.LocalPlayer
local mouse = plr:GetMouse()
local camera = workspace.CurrentCamera
local worldToViewportPoint = camera.worldToViewportPoint
local cc = Instance.new("ColorCorrectionEffect", game.Lighting)
local blur = Instance.new("BlurEffect", game.Lighting)
local sun = Instance.new("SunRaysEffect", game.Lighting)
blur.Size = 0
sun.Intensity = 0

--[Optimisation Variables]

local Drawingnew = Drawing.new
local Color3fromRGB = Color3.fromRGB
local Vector3new = Vector3.new
local Vector2new = Vector2.new
local mathfloor = math.floor
local mathceil = math.ceil

--[Setup Table]

-- esp.enabled

getgenv().esp = {
    players = {},
    enabled = false,
    teamcheck = false,
    fontsize = 16,
    font = 0,
    settings = {
        name = {
            enabled = false,
            outline = false,
            color = Color3fromRGB(255, 255, 255),
            outlineColor = Color3fromRGB(0, 0, 0)
        },
        box = {
            enabled = false,
            outline = false,
            color = Color3fromRGB(255, 255, 255),
            outlineColor = Color3fromRGB(0, 0, 0)
        },
        healthbar = {
            enabled = false,
            outline = false,
            color = Color3fromRGB(0, 255, 0),
            outlineColor = Color3fromRGB(0, 0, 0)
        },
        healthtext = {
            enabled = false,
            outline = false,
            color = Color3fromRGB(255, 255, 255),
            outlineColor = Color3fromRGB(0, 0, 0)
        },
        distance = {
            enabled = false,
            outline = false,
            color = Color3fromRGB(255, 255, 255),
            outlineColor = Color3fromRGB(0, 0, 0)
        }
    }
}

esp.NewDrawing = function(type, properties)
    local newDrawing = Drawingnew(type)

    for i, v in next, properties or {} do
        newDrawing[i] = v
    end

    return newDrawing
end

esp.NewPlayer = function(v)
    esp.players[v] = {
        name = esp.NewDrawing(
            "Text",
            {Color = Color3fromRGB(94, 0, 255), Outline = true, Center = true, Size = 13, Font = 0}
        ),
        boxOutline = esp.NewDrawing("Square", {Color = Color3fromRGB(0, 0, 0), Thickness = 3}),
        box = esp.NewDrawing("Square", {Color = Color3fromRGB(108, 11, 204), Thickness = 1}),
        healthBarOutline = esp.NewDrawing("Line", {Color = Color3fromRGB(0, 0, 0), Thickness = 3}),
        healthBar = esp.NewDrawing("Line", {Color = Color3fromRGB(255, 255, 255), Thickness = 1}),
        healthText = esp.NewDrawing(
            "Text",
            {Color = Color3fromRGB(94, 0, 255), Outline = true, Center = true, Size = 13, Font = 0}
        ),
        distance = esp.NewDrawing(
            "Text",
            {Color = Color3fromRGB(94, 0, 255), Outline = true, Center = true, Size = 13, Font = 0}
        )
    }
end

for _, v in ipairs(plrs:GetPlayers()) do
    esp.NewPlayer(v)
end

plrs.PlayerAdded:Connect(
    function(v)
        esp.NewPlayer(v)
    end
)

plrs.PlayerRemoving:Connect(
    function(v)
        for i, v in pairs(esp.players[v]) do
            v:Remove()
        end
        esp.players[v] = nil
    end
)

local mainLoop =
    rs.RenderStepped:Connect(
    function()
        for i, v in pairs(esp.players) do
            if
                i ~= plr and i.Character and i.Character:FindFirstChild("Humanoid") and
                    i.Character:FindFirstChild("HumanoidRootPart") and
                    i.Character:FindFirstChild("Head")
             then
                local hum = i.Character.Humanoid
                local hrp = i.Character.HumanoidRootPart
                local head = i.Character.Head

                local Vector, onScreen = camera:WorldToViewportPoint(i.Character.HumanoidRootPart.Position)

                local Size =
                    (camera:WorldToViewportPoint(hrp.Position - Vector3new(0, 3, 0)).Y -
                    camera:WorldToViewportPoint(hrp.Position + Vector3new(0, 2.6, 0)).Y) /
                    2
                local BoxSize = Vector2new(mathfloor(Size * 1.5), mathfloor(Size * 1.9))
                local BoxPos = Vector2new(mathfloor(Vector.X - Size * 1.5 / 2), mathfloor(Vector.Y - Size * 1.6 / 2))

                local BottomOffset = BoxSize.Y + BoxPos.Y + 1

                if onScreen and esp.enabled then
                    if esp.settings.name.enabled then
                        v.name.Position = Vector2new(BoxSize.X / 2 + BoxPos.X, BoxPos.Y - 16)
                        v.name.Outline = esp.settings.name.outline
                        v.name.Text = tostring(i)
                        v.name.Color = esp.settings.name.color
                        v.name.OutlineColor = esp.settings.name.outlineColor
                        v.name.Font = esp.font
                        v.name.Size = esp.fontsize

                        v.name.Visible = true
                    else
                        v.name.Visible = false
                    end

                    if
                        esp.settings.distance.enabled and plr.Character and
                            plr.Character:FindFirstChild("HumanoidRootPart")
                     then
                        v.distance.Position = Vector2new(BoxSize.X / 2 + BoxPos.X, BottomOffset)
                        v.distance.Outline = esp.settings.distance.outline
                        v.distance.Text =
                            "[" .. mathfloor((hrp.Position - plr.Character.HumanoidRootPart.Position).Magnitude) .. "m]"
                        v.distance.Color = esp.settings.distance.color
                        v.distance.OutlineColor = esp.settings.distance.outlineColor
                        BottomOffset = BottomOffset + 15

                        v.distance.Font = esp.font
                        v.distance.Size = esp.fontsize

                        v.distance.Visible = true
                    else
                        v.distance.Visible = false
                    end

                    if esp.settings.box.enabled then
                        v.boxOutline.Size = BoxSize
                        v.boxOutline.Position = BoxPos
                        v.boxOutline.Visible = esp.settings.box.outline
                        v.boxOutline.Color = esp.settings.box.outlineColor

                        v.box.Size = BoxSize
                        v.box.Position = BoxPos
                        v.box.Color = esp.settings.box.color
                        v.box.Visible = true
                    else
                        v.boxOutline.Visible = false
                        v.box.Visible = false
                    end

                    if esp.settings.healthbar.enabled then
                        v.healthBar.From = Vector2new((BoxPos.X - 5), BoxPos.Y + BoxSize.Y)
                        v.healthBar.To =
                            Vector2new(
                            v.healthBar.From.X,
                            v.healthBar.From.Y - (hum.Health / hum.MaxHealth) * BoxSize.Y
                        )
                        v.healthBar.Color = esp.settings.healthbar.color
                        v.healthBar.Visible = true

                        v.healthBarOutline.From = Vector2new(v.healthBar.From.X, BoxPos.Y + BoxSize.Y + 1)
                        v.healthBarOutline.To = Vector2new(v.healthBar.From.X, (v.healthBar.From.Y - 1 * BoxSize.Y) - 1)
                        v.healthBarOutline.Color = esp.settings.healthbar.outlineColor
                        v.healthBarOutline.Visible = esp.settings.healthbar.outline
                    else
                        v.healthBarOutline.Visible = false
                        v.healthBar.Visible = false
                    end

                    if esp.settings.healthtext.enabled then
                        v.healthText.Text = tostring(mathfloor((hum.Health / hum.MaxHealth) * 100 + 0.5))
                        v.healthText.Position = Vector2new((BoxPos.X - 20), (BoxPos.Y + BoxSize.Y - 1 * BoxSize.Y) - 1)
                        v.healthText.Color = esp.settings.healthtext.color
                        v.healthText.OutlineColor = esp.settings.healthtext.outlineColor
                        v.healthText.Outline = esp.settings.healthtext.outline

                        v.healthText.Font = esp.font
                        v.healthText.Size = esp.fontsize

                        v.healthText.Visible = true
                    else
                        v.healthText.Visible = false
                    end

                    if esp.teamcheck then
                        if v.TeamColor ~= plr.TeamColor then
                            v.name.Visible = esp.settings.name.enabled
                            v.box.Visible = esp.settings.box.enabled
                            v.healthBar.Visible = esp.settings.healthbar.enabled
                            v.healthText.Visible = esp.settings.healthtext.enabled
                            v.distance.Visible = esp.settings.distance.enabled
                        else
                            v.name.Visible = false
                            v.boxOutline.Visible = false
                            v.box.Visible = false
                            v.healthBarOutline.Visible = false
                            v.healthBar.Visible = false
                            v.healthText.Visible = false
                            v.distance.Visible = false
                        end
                    end
                else
                    v.name.Visible = false
                    v.boxOutline.Visible = false
                    v.box.Visible = false
                    v.healthBarOutline.Visible = false
                    v.healthBar.Visible = false
                    v.healthText.Visible = false
                    v.distance.Visible = false
                end
            else
                v.name.Visible = false
                v.boxOutline.Visible = false
                v.box.Visible = false
                v.healthBarOutline.Visible = false
                v.healthBar.Visible = false
                v.healthText.Visible = false
                v.distance.Visible = false
            end
        end
    end
)

getgenv().esp = esp
--esp


local mouse = game.Players.LocalPlayer:GetMouse()

getgenv().AutoPred = false

local Prey = nil
local Plr  = nil

local Players, Client, Mouse, RS, Camera =
    game:GetService("Players"),
    game:GetService("Players").LocalPlayer,
    game:GetService("Players").LocalPlayer:GetMouse(),
    game:GetService("RunService"),
    game:GetService("Workspace").CurrentCamera

local Circle       = Drawing.new("Circle")
local TracerCircle = Drawing.new("Circle")

Circle.Color           = Color3.new(1,1,1)
Circle.Thickness       = 1
TracerCircle.Color     = Color3.new(1,1,1)
TracerCircle.Thickness = 1

local UpdateFOV = function ()
    if (not Circle and not TracerCircle) then
        return Circle and TracerCircle
    end
    TracerCircle.Visible  = getgenv().SplittaW.TracerFOV.Visible
    TracerCircle.Radius   = getgenv().SplittaW.TracerFOV.Radius * 3
    TracerCircle.Position = Vector2.new(Mouse.X, Mouse.Y + (game:GetService("GuiService"):GetGuiInset().Y))
    
    Circle.Visible  = getgenv().SplittaW.SilentFOV.Visible
    Circle.Radius   = getgenv().SplittaW.SilentFOV.Radius * 3
    Circle.Position = Vector2.new(Mouse.X, Mouse.Y + (game:GetService("GuiService"):GetGuiInset().Y))
    return Circle and TracerCircle
end

RS.Heartbeat:Connect(UpdateFOV)

local WallCheck = function(destination, ignore)
    local Origin    = Camera.CFrame.p
    local CheckRay  = Ray.new(Origin, destination - Origin)
    local Hit       = game.workspace:FindPartOnRayWithIgnoreList(CheckRay, ignore)
    return Hit      == nil
end

local WTS = function (Object)
    local ObjectVector = Camera:WorldToScreenPoint(Object.Position)
    return Vector2.new(ObjectVector.X, ObjectVector.Y)
end

local IsOnScreen = function (Object)
    local IsOnScreen = Camera:WorldToScreenPoint(Object.Position)
    return IsOnScreen
end

local FilterObjs = function (Object)
    if string.find(Object.Name, "Gun") then
        return
    end
    if table.find({"Part", "MeshPart", "BasePart"}, Object.ClassName) then
        return true
    end
end

local ClosestPlrFromMouse = function()
    local Target, Closest = nil, 1/0
    
    for _ ,v in pairs(Players:GetPlayers()) do
    	if getgenv().SplittaW.Silent.WallCheck then
    		if (v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart")) then
    			local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
    			local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
    
    			if (Circle.Radius > Distance and Distance < Closest and OnScreen) and WallCheck(v.Character.HumanoidRootPart.Position, {Client, v.Character}) then
    				Closest = Distance
    				Target = v
    			end
    		end
    	else
    		if (v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart")) then
    			local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
    			local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
    
    			if (Circle.Radius > Distance and Distance < Closest and OnScreen) then
    				Closest = Distance
    				Target = v
    			end
    		end
    	end
    end
    return Target
end

local ClosestPlrFromMouse2 = function()
    local Target, Closest = nil, 1/0
    
    for _ ,v in pairs(Players:GetPlayers()) do
    	if (v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart")) then
        	if getgenv().SplittaW.Tracer.WallCheck then
        		local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
        		local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
        
        		if (Distance < Closest and OnScreen) and WallCheck(v.Character.HumanoidRootPart.Position, {Client, v.Character}) then
        			Closest = Distance
        			Target = v
        		end
                elseif getgenv().SplittaW.Tracer.UseCircleRadius then
            		local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
            		local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                    if (TracerCircle.Radius > Distance and Distance < Closest and OnScreen) and WallCheck(v.Character.HumanoidRootPart.Position, {Client, v.Character}) then
            			Closest = Distance
            			Target = v
                    end
        	    else
        			local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
        			local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
        
        			if (Distance < Closest and OnScreen) then
        				Closest = Distance
        				Target = v
        			end
        		end
            end
        end
    return Target
end

local GetClosestBodyPart = function (character)
    local ClosestDistance = 1/0
    local BodyPart = nil
    
    if (character and character:GetChildren()) then
        for _,  x in next, character:GetChildren() do
            if FilterObjs(x) and IsOnScreen(x) then
                local Distance = (WTS(x) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if (Circle.Radius > Distance and Distance < ClosestDistance) then
                    ClosestDistance = Distance
                    BodyPart = x
                end
            end
        end
    end
    return BodyPart
end

local GetClosestBodyPartV2 = function (character)
    local ClosestDistance = 1/0
    local BodyPart = nil
    
    if (character and character:GetChildren()) then
        for _,  x in next, character:GetChildren() do
            if FilterObjs(x) and IsOnScreen(x) then
                local Distance = (WTS(x) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if (Distance < ClosestDistance) then
                    ClosestDistance = Distance
                    BodyPart = x
                end
            end
        end
    end
    return BodyPart
end

Mouse.KeyDown:Connect(function(Key)
    local Keybind = getgenv().SplittaW.Tracer.Key:lower()
    if (Key == Keybind) then
        if getgenv().SplittaW.Tracer.Enabled == true then
            IsTargetting = not IsTargetting
            if IsTargetting then
                Plr = ClosestPlrFromMouse2()
            else
                if Plr ~= nil then
                    Plr = nil
                    IsTargetting = false
                end
            end
        end
    end
end)

Mouse.KeyDown:Connect(function(Key)
    local Keybind = getgenv().SplittaW.Silent.Keybind:lower()
    if (Key == Keybind) and getgenv().SplittaW.Silent.UseKeybind == true then
            if getgenv().SplittaW.Silent.Enabled == true then
				getgenv().SplittaW.Silent.Enabled = false
                if getgenv().SplittaW.Both.SendNotification then
                    game.StarterGui:SetCore(
                        "SendNotification",
                        {
                            Title = "SplittaW",
                            Text = "Disabled Silent Aim",
                            Icon = "",
                            Duration = 1
                        }
                    )
                end
            else
				getgenv().SplittaW.Silent.Enabled = true
                if getgenv().SplittaW.Both.SendNotification then
                    game.StarterGui:SetCore(
                        "SendNotification",
                        {
                            Title = "SplittaW",
                            Text = "Enabled Silent Aim",
                            Icon = "",
                            Duration = 1
                        }
                    )
                end
            end
        end
    end
)


Mouse.KeyDown:Connect(function(Key)
    local Keybind = getgenv().SplittaW.Both.UnderGroundKey:lower()
    if (Key == Keybind) and getgenv().SplittaW.Both.UseUnderGroundKeybind == true then
            if getgenv().SplittaW.Both.UnderGroundReolver == true then
				getgenv().SplittaW.Both.UnderGroundReolver = false
                if getgenv().SplittaW.Both.SendNotification then
                    game.StarterGui:SetCore(
                        "SendNotification",
                        {
                            Title = "SplittaW",
                            Text = "Disabled UnderGround Resolver",
                            Icon = "",
                            Duration = 1
                        }
                    )
                end
            else
				getgenv().SplittaW.Both.UnderGroundReolver = true
                if getgenv().SplittaW.Both.SendNotification then
                    game.StarterGui:SetCore(
                        "SendNotification",
                        {
                            Title = "SplittaW",
                            Text = "Enabled UnderGround Resolver",
                            Icon = "",
                            Duration = 1
                        }
                    )
                end
            end
        end
    end
)

Mouse.KeyDown:Connect(function(Key)
    local Keybind = getgenv().SplittaW.Both.DetectDesyncKey:lower()
    if (Key == Keybind) and getgenv().SplittaW.Both.UsDetectDesyncKeybind == true then
            if getgenv().SplittaW.Both.DetectDesync == true then
				getgenv().SplittaW.Both.DetectDesync = false
                if getgenv().SplittaW.Both.SendNotification then
                    game.StarterGui:SetCore(
                        "SendNotification",
                        {
                            Title = "SplittaW",
                            Text = "Disabled Desync Resolver",
                            Icon = "",
                            Duration = 1
                        }
                    )
                end
            else
				getgenv().SplittaW.Both.DetectDesync = true
                if getgenv().SplittaW.Both.SendNotification then
                    game.StarterGui:SetCore(
                        "SendNotification",
                        {
                            Title = "SplittaW",
                            Text = "Enabled Desync Resolver",
                            Icon = "",
                            Duration = 1
                        }
                    )
                end
            end
        end
    end
)

local grmt = getrawmetatable(game)
local backupindex = grmt.__index
setreadonly(grmt, false)

grmt.__index = newcclosure(function(self, v)
    if (getgenv().SplittaW.Silent.Enabled and Mouse and tostring(v) == "Hit") then
        if Prey and Prey.Character then
    		if getgenv().SplittaW.Silent.PredictMovement then
    			local endpoint = game.Players[tostring(Prey)].Character[getgenv().SplittaW.Silent.Part].CFrame + (
    				game.Players[tostring(Prey)].Character[getgenv().SplittaW.Silent.Part].Velocity * getgenv().SplittaW.Silent.PredictionVelocity
    			)
    			return (tostring(v) == "Hit" and endpoint)
    		else
    			local endpoint = game.Players[tostring(Prey)].Character[getgenv().SplittaW.Silent.Part].CFrame
    			return (tostring(v) == "Hit" and endpoint)
    		end
        end
    end
    return backupindex(self, v)
end)

RS.Heartbeat:Connect(function()
	if getgenv().SplittaW.Silent.Enabled then
	    if Prey and Prey.Character and Prey.Character:WaitForChild(getgenv().SplittaW.Silent.Part) then
            if getgenv().SplittaW.Both.DetectDesync == true and Prey.Character:WaitForChild("HumanoidRootPart").Velocity.magnitude > getgenv().SplittaW.Both.DesyncDetection then            
                pcall(function()
                    local TargetVel = Prey.Character[getgenv().SplittaW.Silent.Part]
                    TargetVel.Velocity = Vector3.new(0, 0, 0)
                    TargetVel.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                end)
            end
            if getgenv().SplittaW.Silent.AntiGroundShots == true and Prey.Character:FindFirstChild("Humanoid") == Enum.HumanoidStateType.Freefall then
                pcall(function()
                    local TargetVelv5 = Prey.Character[getgenv().SplittaW.Silent.Part]
                    TargetVelv5.Velocity = Vector3.new(TargetVelv5.Velocity.X, (TargetVelv5.Velocity.Y * 0.5), TargetVelv5.Velocity.Z)
                    TargetVelv5.AssemblyLinearVelocity = Vector3.new(TargetVelv5.Velocity.X, (TargetVelv5.Velocity.Y * 0.5), TargetVelv5.Velocity.Z)
                end)
            end
            if getgenv().SplittaW.Both.UnderGroundReolver == true then            
                pcall(function()
                    local TargetVelv2 = Prey.Character[getgenv().SplittaW.Silent.Part]
                    TargetVelv2.Velocity = Vector3.new(TargetVelv2.Velocity.X, 0, TargetVelv2.Velocity.Z)
                    TargetVelv2.AssemblyLinearVelocity = Vector3.new(TargetVelv2.Velocity.X, 0, TargetVelv2.Velocity.Z)
                end)
            end
	    end
	end
    if getgenv().SplittaW.Tracer.Enabled == true then
        if getgenv().SplittaW.Both.DetectDesync == true and Plr and Plr.Character and Plr.Character:WaitForChild(getgenv().SplittaW.Tracer.Part) and Plr.Character:WaitForChild("HumanoidRootPart").Velocity.magnitude > getgenv().SplittaW.Both.DesyncDetection then
            pcall(function()
                local TargetVelv3 = Plr.Character[getgenv().SplittaW.Tracer.Part]
                TargetVelv3.Velocity = Vector3.new(0, 0, 0)
                TargetVelv3.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            end)
        end
        if getgenv().SplittaW.Both.UnderGroundReolver == true and Plr and Plr.Character and Plr.Character:WaitForChild(getgenv().SplittaW.Tracer.Part)then
            pcall(function()
                local TargetVelv4 = Plr.Character[getgenv().SplittaW.Tracer.Part]
                TargetVelv4.Velocity = Vector3.new(TargetVelv4.Velocity.X, 0, TargetVelv4.Velocity.Z)
                TargetVelv4.AssemblyLinearVelocity = Vector3.new(TargetVelv4.Velocity.X, 0, TargetVelv4.Velocity.Z)
            end)
        end
    end
end)

RS.RenderStepped:Connect(function()
	if getgenv().SplittaW.Silent.Enabled then
        if getgenv().SplittaW.Silent.CheckIf_KO == true and Prey and Prey.Character then 
            local KOd = Prey.Character:WaitForChild("BodyEffects")["K.O"].Value
            local Grabbed = Prey.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
            if KOd or Grabbed then
                Prey = nil
            end
        end
	end
    if getgenv().SplittaW.Tracer.Enabled == true then
        if getgenv().SplittaW.Tracer.CheckIf_KO == true and Plr and Plr.Character then 
            local KOd = Plr.Character:WaitForChild("BodyEffects")["K.O"].Value
            local Grabbed = Plr.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
            if KOd or Grabbed then
                Plr = nil
                IsTargetting = false
            end
        end
		if getgenv().SplittaW.Tracer.DisableTargetDeath == true and Plr and Plr.Character:FindFirstChild("Humanoid") then
			if Plr.Character.Humanoid.health < 4 then
				Plr = nil
				IsTargetting = false
			end
		end
		if getgenv().SplittaW.Tracer.DisableLocalDeath == true and Plr and Plr.Character:FindFirstChild("Humanoid") then
			if Client.Character.Humanoid.health < 4 then
				Plr = nil
				IsTargetting = false
			end
		end
        if getgenv().SplittaW.Tracer.DisableOutSideCircle == true and Plr and Plr.Character and Plr.Character:WaitForChild("HumanoidRootPart") then
            if
            TracerCircle.Radius <
                (Vector2.new(
                    Camera:WorldToScreenPoint(Plr.Character.HumanoidRootPart.Position).X,
                    Camera:WorldToScreenPoint(Plr.Character.HumanoidRootPart.Position).Y
                ) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
             then
                Plr = nil
                IsTargetting = false
            end
        end
		if getgenv().SplittaW.Tracer.PredictMovement and Plr and Plr.Character and Plr.Character:FindFirstChild(getgenv().SplittaW.Tracer.Part) then
			if getgenv().SplittaW.Tracer.UseShake then
				local Main = CFrame.new(Camera.CFrame.p,Plr.Character[getgenv().SplittaW.Tracer.Part].Position + Plr.Character[getgenv().SplittaW.Tracer.Part].Velocity * getgenv().SplittaW.Tracer.PredictionVelocity +
				Vector3.new(
					math.random(-getgenv().SplittaW.Tracer.ShakeValue, getgenv().SplittaW.Tracer.ShakeValue),
					math.random(-getgenv().SplittaW.Tracer.ShakeValue, getgenv().SplittaW.Tracer.ShakeValue),
					math.random(-getgenv().SplittaW.Tracer.ShakeValue, getgenv().SplittaW.Tracer.ShakeValue)
				) * 0.1)
				Camera.CFrame = Camera.CFrame:Lerp(Main, getgenv().SplittaW.Tracer.Smoothness, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			else
    			local Main = CFrame.new(Camera.CFrame.p,Plr.Character[getgenv().SplittaW.Tracer.Part].Position + Plr.Character[getgenv().SplittaW.Tracer.Part].Velocity * getgenv().SplittaW.Tracer.PredictionVelocity)
    			Camera.CFrame = Camera.CFrame:Lerp(Main, getgenv().SplittaW.Tracer.Smoothness, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			end
		elseif getgenv().SplittaW.Tracer.PredictMovement == false and Plr and Plr.Character and Plr.Character:FindFirstChild(getgenv().SplittaW.Tracer.Part) then
			if getgenv().SplittaW.Tracer.UseShake then
				local Main = CFrame.new(Camera.CFrame.p,Plr.Character[getgenv().SplittaW.Tracer.Part].Position +
				Vector3.new(
					math.random(-getgenv().SplittaW.Tracer.ShakeValue, getgenv().SplittaW.Tracer.ShakeValue),
					math.random(-getgenv().SplittaW.Tracer.ShakeValue, getgenv().SplittaW.Tracer.ShakeValue),
					math.random(-getgenv().SplittaW.Tracer.ShakeValue, getgenv().SplittaW.Tracer.ShakeValue)
				) * 0.1)
				Camera.CFrame = Camera.CFrame:Lerp(Main, getgenv().SplittaW.Tracer.Smoothness, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		    else
    			local Main = CFrame.new(Camera.CFrame.p,Plr.Character[getgenv().SplittaW.Tracer.Part].Position)
    			Camera.CFrame = Camera.CFrame:Lerp(Main, getgenv().SplittaW.Tracer.Smoothness, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		    end
		end
	end
end)

task.spawn(function ()
    while task.wait() do
    	if getgenv().SplittaW.Silent.Enabled then
            Prey = ClosestPlrFromMouse()
    	end
        if Plr then
            if getgenv().SplittaW.Tracer.Enabled and (Plr.Character) and getgenv().SplittaW.Tracer.ClosestPart then
                getgenv().SplittaW.Tracer.Part = tostring(GetClosestBodyPartV2(Plr.Character))
            end
        end
        if Prey then
            if getgenv().SplittaW.Silent.Enabled and (Prey.Character) and getgenv().SplittaW.Silent.ClosestPart then
                getgenv().SplittaW.Silent.Part = tostring(GetClosestBodyPart(Prey.Character))
            end
        end
    end
end)

local Script = {Functions = {}}
    Script.Functions.getToolName = function(name)
        local split = string.split(string.split(name, "[")[2], "]")[1]
        return split
    end
    Script.Functions.getEquippedWeaponName = function()
        if (Client.Character) and Client.Character:FindFirstChildWhichIsA("Tool") then
           local Tool =  Client.Character:FindFirstChildWhichIsA("Tool")
           if string.find(Tool.Name, "%[") and string.find(Tool.Name, "%]") and not string.find(Tool.Name, "Wallet") and not string.find(Tool.Name, "Phone") then
              return Script.Functions.getToolName(Tool.Name)
           end
        end
        return nil
    end
    RS.RenderStepped:Connect(function()
    if Script.Functions.getEquippedWeaponName() ~= nil then
        local WeaponSettings = getgenv().SplittaW.GunFOV[Script.Functions.getEquippedWeaponName()]
        if WeaponSettings ~= nil and getgenv().SplittaW.GunFOV.Enabled == true then
            getgenv().SplittaW.SilentFOV.Radius = WeaponSettings.FOV
        else
            getgenv().SplittaW.SilentFOV.Radius = getgenv().SplittaW.SilentFOV.Radius
        end
    end
end)

repo = 'https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

Library:Notify("Loading...", 2)

wait(2)

local Window = Library:CreateWindow({
    Title = ' Streamable GUI',
    Center = true, 
    AutoShow = true,
})

local Tabs = {
    ['Combat'] = Window:AddTab("Combat"),  
    ['Visuals'] = Window:AddTab("Visuals"), 
    ['Misc'] = Window:AddTab("Misc"), 
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local CombatLB = Tabs.Combat:AddLeftGroupbox('Silent-Lock')
local CombatRB = Tabs.Combat:AddRightGroupbox('Tracer-Lock')
local ResolveLB = Tabs.Combat:AddLeftGroupbox('Resolvers')

local VisualsRB = Tabs.Visuals:AddRightGroupbox('Visuals Misc')
local VisualsLB = Tabs.Visuals:AddLeftGroupbox('Visuals Other')

Library:Notify("Loaded!", 5)

-- Tracer-Lock Group Start --

CombatLB:AddToggle('SilentEnb', {
    Text = 'Silent-Lock',
    Default = false,
    Tooltip = 'Enables Silent Lock',
})

CombatLB:AddToggle('SilentFOVEnb', {
    Text = 'Silent-FOV',
    Default = false,
    Tooltip = 'Enables FOV',
})

CombatLB:AddSlider('SilentFOVSize', {
    Text = 'FOV Size',
    Default = 20,
    Min = 0,
    Max = 360,
    Rounding = 1,
    Compact = false,
})

CombatLB:AddDropdown('SilentHitPT', {
    Values = { "Head", "LowerTorso", "HumanoidRootPart", "RightUpperArm", "LeftUpperArm", "RightLowerLeg", "LeftLowerLeg", },
    Default = 7,
    Multi = true,

    Text = 'Hit-Parts',
    Tooltip = 'Hits Whatever Selected parts'
})

CombatLB:AddToggle('SilentClosePT', {
    Text = 'Hit Closest-Part',
    Default = false,
    Tooltip = 'Lock Hits Whatever Part Your Cursor Is On!',
})

CombatLB:AddToggle('SilentPredEnb', {
    Text = 'Prediction',
    Default = false,
    Tooltip = 'Enables Prediction!',
})

CombatLB:AddToggle('SilentAutoPred', {
    Text = 'Auto-Prediction',
    Default = false,
    Tooltip = 'Auto Puts Sets For You!',
})

CombatLB:AddInput('SilentPred', {
    Default = '0.131',
    Numeric = true,
    Finished = true,

    Text = 'Prediction',
    Tooltip = 'Changes The Prediction Of The Silent-Lock!',

    Placeholder = '0.131',
})

CombatLB:AddToggle('SilentGroundEnb', {
    Text = 'Anti-Ground Shots',
    Default = false,
    Tooltip = 'Lock Doesnt Shoot The Ground',
})

CombatLB:AddToggle('SilentWallEnb', {
    Text = 'Wall-Check',
    Default = false,
    Tooltip = 'Unlocks If Player Is Behind A Wall Or Not Visible',
})

CombatLB:AddToggle('SilentKOEnb', {
    Text = 'Down-Check',
    Default = false,
    Tooltip = 'Unlocks If Player Is Down',
})

Toggles.SilentEnb:OnChanged(function()
    getgenv().SplittaW.Silent.Enabled = Toggles.SilentEnb.Value
end)

Toggles.SilentFOVEnb:OnChanged(function()
    getgenv().SplittaW.SilentFOV.Visible = Toggles.SilentFOVEnb.Value
end)

local Number = Options.SilentFOVSize.Value
Options.SilentFOVSize:OnChanged(function()
    getgenv().SplittaW.SilentFOV.Radius = Options.SilentFOVSize.Value
end)

Options.SilentHitPT:OnChanged(function()
    getgenv().SplittaW.Silent.Part = Options.SilentHitPT.Value
end)

Toggles.SilentClosePT:OnChanged(function()
    getgenv().SplittaW.Silent.ClosestPart = Toggles.SilentClosePT.Value
end)

Toggles.SilentPredEnb:OnChanged(function()
    getgenv().SplittaW.Silent.PredictMovement = Toggles.SilentPredEnb.Value
end)

Toggles.SilentAutoPred:OnChanged(function()
    getgenv().AutoPred = Toggles.SilentAutoPred.Value
end)

Options.SilentPred:OnChanged(function()
    getgenv().SplittaW.Silent.PredictionVelocity = Options.SilentPred.Value
end)

Toggles.SilentGroundEnb:OnChanged(function()
    getgenv().SplittaW.Silent.AntiGroundShots = Toggles.SilentGroundEnb.Value
end)

Toggles.SilentWallEnb:OnChanged(function()
    getgenv().SplittaW.Silent.WallCheck = Toggles.SilentWallEnb.Value
end)

Toggles.SilentKOEnb:OnChanged(function()
    getgenv().SplittaW.Silent.CheckIf_KO = Toggles.SilentKOEnb.Value
end)

-- Tracer Group Start --

CombatRB:AddToggle('TracerEnb', {
    Text = 'Tracer-Lock',
    Default = false,
    Tooltip = 'Enables Tracer Lock',
})

CombatRB:AddToggle('TracerFOVEnb', {
    Text = 'Tracer-FOV',
    Default = false,
    Tooltip = 'Enables Tracer FOV',
})

CombatRB:AddToggle('TracerFOVUse', {
    Text = 'Use FOV',
    Default = false,
    Tooltip = 'Uses FOV',
})

CombatRB:AddToggle('TracerOOFOVEnb', {
    Text = 'Disable Outside FOV',
    Default = false,
    Tooltip = 'Unlocks If Target Is Out Of FOV',
})

CombatRB:AddSlider('TracerFOVSize', {
    Text = 'FOV Size',
    Default = 50,
    Min = 0,
    Max = 360,
    Rounding = 1,
    Compact = false,
})

CombatRB:AddInput('TracerSmoothNumb', {
    Default = '0.022',
    Numeric = true,
    Finished = true,

    Text = 'Smoothness',
    Tooltip = 'Changes The Smoothness',

    Placeholder = '0.022',
})

CombatRB:AddDropdown('TracerhitPT', {
    Values = { "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", },
    Default = 2,
    Multi = true,

    Text = 'Hit-Parts',
    Tooltip = 'Hits Whatever Selected parts'
})

CombatRB:AddToggle('TracerCloseEnb', {
    Text = 'Closest-Part',
    Default = false,
    Tooltip = 'Hits Closest-Part',
})

CombatRB:AddToggle('TracerPredEnb', {
    Text = 'Prediction',
    Default = false,
    Tooltip = 'Enables Prediction!',
})

CombatRB:AddToggle('TracerAutoPredEnb', {
    Text = 'Auto-Prediction',
    Default = false,
    Tooltip = 'Enables Auto Prediction!',
})

CombatRB:AddInput('TracerPredNumb', {
    Default = '0.146',
    Numeric = true,
    Finished = true,

    Text = 'Prediction',
    Tooltip = 'Changes The Prediction Of The Silent-Lock!',

    Placeholder = '0.146',
})

CombatRB:AddToggle('TracerShakeEnb', {
    Text = 'Shake',
    Default = false,
    Tooltip = 'Makes Cam Shake',
})

CombatRB:AddInput('TracerShakeNumb', {
    Default = '5',
    Numeric = true,
    Finished = true,

    Text = 'Shake Value',
    Tooltip = 'Changes The Shake Value',

    Placeholder = '5',
})

CombatRB:AddToggle('WallCheckEnb', {
    Text = 'Wall Check',
    Default = false,
    Tooltip = 'Locks Onto Only Visible Players',
})

CombatRB:AddToggle('DownCheckEnb', {
    Text = 'Down Check',
    Default = false,
    Tooltip = 'Unlocks If Player Is Down',
})

Toggles.TracerEnb:OnChanged(function()
    getgenv().SplittaW.Tracer.Enabled = Toggles.TracerEnb.Value
end)

Toggles.TracerFOVEnb:OnChanged(function()
    getgenv().SplittaW.TracerFOV.Visible = Toggles.TracerFOVEnb.Value
end)

Toggles.TracerFOVUse:OnChanged(function()
    getgenv().SplittaW.TracerFOV.UseCircleRadius = Toggles.TracerFOVUse.Value
end)

Toggles.TracerOOFOVEnb:OnChanged(function()
    getgenv().SplittaW.TracerFOV.DisableOutSideCircle = Toggles.TracerOOFOVEnb.Value
end)

local Number = Options.TracerFOVSize.Value
Options.TracerFOVSize:OnChanged(function()
    getgenv().SplittaW.TracerFOV.Radius = Options.TracerFOVSize.Value
end)

Options.TracerhitPT:OnChanged(function()
    getgenv().SplittaW.Tracer.Part = Options.TracerhitPT.Value
end)

Toggles.TracerCloseEnb:OnChanged(function()
    getgenv().SplittaW.Tracer.ClosestPart = Toggles.TracerCloseEnb.Value
end)

Toggles.TracerPredEnb:OnChanged(function()
    getgenv().SplittaW.Tracer.Prediction = Toggles.TracerPredEnb.Value
end)

Toggles.TracerAutoPredEnb:OnChanged(function()
    getgenv().AutoPred = Toggles.TracerAutoPredEnb.Value
end)

Options.TracerPredNumb:OnChanged(function()
    getgenv().SplittaW.Tracer.PredictionVelocity = Options.TracerPredNumb.Value
end)

Options.TracerSmoothNumb:OnChanged(function()
    getgenv().SplittaW.Tracer.Smoothness = Options.TracerSmoothNumb.Value
end)

Toggles.TracerShakeEnb:OnChanged(function()
    getgenv().SplittaW.Tracer.UseShake = Toggles.TracerShakeEnb.Value
end)

Options.TracerShakeNumb:OnChanged(function()
    getgenv().SplittaW.Tracer.ShakeValue = Options.TracerShakeNumb.Value
end)

Toggles.WallCheckEnb:OnChanged(function()
    getgenv().SplittaW.Tracer.WallCheck = Toggles.WallCheckEnb.Value
end)

Toggles.DownCheckEnb:OnChanged(function()
    getgenv().SplittaW.Tracer.DownCheckEnb = Toggles.DownCheckEnb.Value
end)

-- Resolver Group Start --

ResolveLB:AddToggle('DetectDesyncEnb', {
    Text = 'Detect Desync',
    Default = false,
    Tooltip = 'Detects Desync',
})

ResolveLB:AddInput('DesyncNumb', {
    Default = '80',
    Numeric = true,
    Finished = true,

    Text = 'Prediction',
    Tooltip = 'Changes Desync Detection',

    Placeholder = '80',
})

ResolveLB:AddToggle('UnderEnb', {
    Text = 'Underground Resolver',
    Default = false,
    Tooltip = 'Resolves Underground Anti-Lock',
})

ResolveLB:AddToggle('SendNotiEnb', {
    Text = 'Allow Notifications',
    Default = false,
    Tooltip = 'Allows Notifications',
})

Toggles.DetectDesyncEnb:OnChanged(function()
    getgenv().SplittaW.Both.DetectDesync = Toggles.DetectDesyncEnb.Value
end)

Options.DesyncNumb:OnChanged(function()
    getgenv().SplittaW.Both.DesyncDetection = Options.DesyncNumb.Value
end)

Toggles.UnderEnb:OnChanged(function()
    getgenv().SplittaW.Both.UnderGroundReolver = Toggles.UnderEnb.Value
end)

Toggles.SendNotiEnb:OnChanged(function()
    getgenv().SplittaW.Both.SendNotification = Toggles.SendNotiEnb.Value
end)

-- Resolver Group End --

-- Visual Other Group Start --

VisualsLB:AddToggle('ESPEnb', {
    Text = 'Enable ESP',
    Default = false,
    Tooltip = 'Enables ESP',
})

VisualsLB:AddToggle('BoxEnb', {
    Text = 'Box',
    Default = false,
    Tooltip = 'Enables Boxes',
})

VisualsLB:AddToggle('NameEnb', {
    Text = 'Name',
    Default = false,
    Tooltip = 'Enables Names',
})

VisualsLB:AddToggle('HealthEnb', {
    Text = 'Healthbar',
    Default = false,
    Tooltip = 'Enables Healthbars',
})

VisualsLB:AddToggle('DistanceEnb', {
    Text = 'Distance',
    Default = false,
    Tooltip = 'Enables Distance',
})

Toggles.ESPEnb:OnChanged(function()
    getgenv().esp.enabled = Toggles.ESPEnb.Value
end)

Toggles.BoxEnb:OnChanged(function()
    getgenv().esp.settings.box.enabled = Toggles.ESPEnb.Value
    getgenv().esp.settings.box.outline = Toggles.ESPEnb.Value
end)

Toggles.NameEnb:OnChanged(function()
    getgenv().esp.settings.name.enabled = Toggles.NameEnb.Value
    getgenv().esp.settings.name.outline = Toggles.NameEnb.Value
end)

Toggles.HealthEnb:OnChanged(function()
    getgenv().esp.settings.healthbar.enabled = Toggles.HealthEnb.Value
    getgenv().esp.settings.healthbar.outline = Toggles.HealthEnb.Value
end)

Toggles.DistanceEnb:OnChanged(function()
    getgenv().esp.settings.distance.enabled = Toggles.DistanceEnb.Value
    getgenv().esp.settings.distance.outline = Toggles.DistanceEnb.Value
end)

-- Visual Misc Group Start --

local AimViewer = VisualsRB:AddButton("Launch Aimviewer", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/Aim%20Viewer"))()
end)

local NameESP = VisualsRB:AddButton("Launch Name-ESP", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/name%20esp"))()
end)

local ChatSpy = VisualsRB:AddButton("Launch ChatSpy", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/ChatSpy"))()
end)

local AutoArmor = VisualsRB:AddButton("Launch Auto-Armor", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/AutoArmor"))()
end)

local AntiSelf = VisualsRB:AddButton("Anti Self Viewer", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/antiaim%20self%20show"))()
end)

local Forcereset = VisualsRB:AddButton("Force-Reset", function()
    for L_170_forvar0, L_171_forvar1 in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
        if L_171_forvar1:IsA("BasePart") then
            L_171_forvar1:Destroy()
		end
    end
end)

local Fps = VisualsRB:AddButton("FPS-Boost", function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/fpsboost%3F"))()
end)

local CheckIf = VisualsRB:AddButton("Staff In-Game?", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Other/main/checkstaffhood"))()
end)

local FatalitySyn = VisualsRB:AddButton("Fatality Synapse Anti GUI", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/tailgater/Fatality/main/Synapse", true))()
end)

-- Visual Misc Group End --

Library:SetWatermarkVisibility(true)
Library:SetWatermark("Streamable GUI | User | ".. game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name)
Library.KeybindFrame.Visible = false;
Library:OnUnload(function()
    Library:Notify("Unloading...", 3)
    wait(3)
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end) 
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'V', NoUI = true, Text = 'Menu keybind' }) 

Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings() 
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' }) 
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')
SaveManager:BuildConfigSection(Tabs['UI Settings']) 
ThemeManager:ApplyToTab(Tabs['UI Settings'])

if getgenv().AutoPred == true then
pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
             split = string.split(pingvalue,'(')
             ping = tonumber(split[1])
            if ping < 130 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.151
                SilentPred:SetValue("0.151")
            elseif ping < 125 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.149
                SilentPred:SetValue("0.149")
            elseif ping < 110 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.146
                SilentPred:SetValue("0.146")
            elseif ping < 105 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.138
                SilentPred:SetValue("0.138")
            elseif ping < 90 then
                PredictionValue = 0.136
                getgenv().SplittaW.Silent.PredictionVelocity = 0.136
                SilentPred:SetValue("0.136")
            elseif ping < 80 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.134
                SilentPred:SetValue("0.134")
            elseif ping < 70 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.131
                SilentPred:SetValue("0.131")
            elseif ping < 60 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.1229
                SilentPred:SetValue("0.1229")
            elseif ping < 50 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.1225
                SilentPred:SetValue("0.1225")
            elseif ping < 40 then
                getgenv().SplittaW.Silent.PredictionVelocity = 0.1256
                SilentPred:SetValue("0.1256")
            end
end
